#pragma once
#include <natException.h>
#include "Basic/Token.h"
#include <map>

namespace NatsuLang
{
	class Preprocessor;

	namespace Lex
	{
		DeclareException(LexerException, NatsuLib::natException, "Exception generated by lexer.");

		class Lexer
			: public NatsuLib::natRefObjImpl<Lexer>, public NatsuLib::nonmovable
		{
		public:
			explicit Lexer(nuInt fileID, nStrView buffer, Preprocessor& preprocessor);

			nBool Lex(Token& result);

			nuInt GetFileID() const noexcept;

			void EnableCodeCompletion(nBool value) noexcept
			{
				m_CodeCompletionEnabled = value;
			}

			nBool IsCodeCompletionEnabled() const noexcept
			{
				return m_CodeCompletionEnabled;
			}

			///	@brief	获取指定位置所处的行的范围
			///	@param	loc	要获取行范围的位置
			///	@return	行号及范围，若发生错误则全为空
			std::pair<nuInt, SourceRange> GetLine(SourceLocation loc) const noexcept;

		private:
			using Iterator = nStrView::const_iterator;
			using CharType = nStrView::CharType;

			Preprocessor& m_Preprocessor;

			nBool m_CodeCompletionEnabled;

			const nStrView m_Buffer;
			// 当前处理的指针，指向下一次被处理的字符
			Iterator m_Current;

			const nuInt m_FileID;

			nuInt m_CurrentLine;

			// Key: 起始
			// Value: 行数，结束
			std::map<Iterator, std::pair<nuInt, Iterator>> m_LineCache;

			nBool skipWhitespace(Token& result, Iterator cur);
			nBool skipLineComment(Token& result, Iterator cur);
			nBool skipBlockComment(Token& result, Iterator cur);

			nBool lexNumericLiteral(Token& result, Iterator cur);
			nBool lexIdentifier(Token& result, Iterator cur);
			nBool lexCharLiteral(Token& result, Iterator cur);
			nBool lexStringLiteral(Token& result, Iterator cur);

		public:
			class Memento
			{
				friend class Lexer;

				Memento(nuInt currentLine, Iterator current, std::map<Iterator, std::pair<nuInt, Iterator>>::const_iterator lineCacheIter) noexcept
					: m_CurrentLine{ currentLine }, m_Current{ current }, m_LineCacheIter{ std::move(lineCacheIter) }
				{
				}

				nuInt m_CurrentLine;
				Iterator m_Current;
				std::map<Iterator, std::pair<nuInt, Iterator>>::const_iterator m_LineCacheIter;
			};

			Memento SaveToMemento() const noexcept;
			void RestoreFromMemento(Memento memento) noexcept;
		};
	}
}
